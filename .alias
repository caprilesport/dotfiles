#!/usr/bin/env bash

# shortcuts
alias :q='exit'
alias :!='exit'

# clusters
alias qsn='ssh newton "qstat"'
alias qsj='ssh jupiter "qstat"'
alias qdelnew='ssh newton "qdel"'
alias qdeljup='ssh jupiter "qdel"'

# Enable aliases to be sudoâ€™ed
alias sudo='sudo '

# system
alias update='sudo pacman -Syyu'
alias mkdir='mkdir -p'
alias reload='source ~/.zshrc'

# programs 
alias ipy='ipython'
alias za='zellij attach `zellij ls -s | fzf` 2> /dev/null'
alias lg='lazygit'
alias cp='cp -r'
alias ged='gedent'
alias ggen='gedent gen `gedent template list | fzf` '
alias periodic-table='npx periodic-table-cli'
alias copy='xclip -selection clipboard'

# ledger alias
alias hled='hledger'

# lsd
alias l='ls -l'
alias la='ls -a'
alias lla='ls -la'
alias lt='ls --tree'

#cargo
alias cargoclippy='cargo clippy --fix --allow-dirty --allow-staged -- -W clippy::pedantic -W clippy::nursery'

# git 
alias g='git'
alias gf='git diff --name-only'
alias gac='g a . && g c "updates" && g ps'

# csync
alias cs='csync'

#rm tmp files when pullin in wrong time
alias rmtmp='rm *.densities *.txt *.hostnames *res.Dipoles *.grd *.gbw *.smd* *.res* *.cpcm'

#scripts environment
alias activatescripts='. ~/projects/scripts/.scripts_environment/bin/activate'

#qchemistry
alias energy='grep "Final Gibbs free energy" **/*.out'
alias imfreq='grep -i "imaginary mode" **/*.out'

# more complicated functions

# open foulder if hx called with no arguments
hx() {
  if [[ $# -eq 0 ]]; then
    command hx .
  else
    command hx "$@"
  fi
}

# connect phone bluetoothctl
alias muitagentenolab='echo "connect 74:2A:8A:A8:EC:9B" | bluetoothctl'
alias soosguri='echo "disconnect "74:2A:8A:A8:EC:9B" | bluetoothctl'

# orca stuff
alias energy='grep -i "final gibbs free energy" **/*.out'
alias imfreq='grep -i "imaginary mode" **/*.out'
alias geomcyclep='grep -i "geometry optimization cycle" **/*.out'
alias scanprogress='grep -i "RELAXED SURFACE SCAN STEP" **/*.out'

function yy() {
	local tmp="$(mktemp -t "yazi-cwd.XXXXXX")"
	yazi "$@" --cwd-file="$tmp"
	if cwd="$(cat -- "$tmp")" && [ -n "$cwd" ] && [ "$cwd" != "$PWD" ]; then
		cd -- "$cwd"
	fi
	rm -f -- "$tmp"
}

# ditch the outputs of chemcraft
molv () {
    for file in "$@"; do
        wine /home/vport/.wine/drive_c/Chemcraft/Chemcraft.exe "$file" &> /dev/null &
    done
}

# oneliner to send files and ssh to cluster
sngo() {
  cs "$1" push && sshcd "$1" 
}

# oneliner to optimize a structure with xtb without cluttering the current dir
xtbopt() {
  mkdir .xtbopt && cp "$1" .xtbopt && cd .xtbopt && xtb "$1" --opt && cp xtbopt.xyz .. && cd ..
}

cleanorcadir() {
    local dry_run=false
    local patterns_to_keep=()

    # Check for the "--dry-run" flag and remove it from the arguments if present
    for arg in "$@"; do
        if [ "$arg" == "--dry-run" ]; then
            dry_run=true
        else
            patterns_to_keep+=("$arg")
        fi
    done
    
    # Build the find command dynamically
    local find_command='find . -type f \( -name "*.gbw" -o -name "*.cpcm" -o -name "*.densities" -o -name "*.hostnames" -o -name "*job*" -o -name "*engrad" -o -name "*opt" -o -name "*smd*" \)'
    
    # Add exclusion patterns based on user input
    for pattern in "${patterns_to_keep[@]}"; do
        find_command+=" ! -name \"*$pattern*\""
    done

    # Execute the dynamically constructed find command
    local files=$(eval $find_command)

    # Check if any files were found
    if [ -n "$files" ]; then
        echo "The following files would be deleted:"
        echo "$files"

        # If it's not a dry run, delete the files
        if [ "$dry_run" == false ]; then
            echo "$files" | xargs rm
            echo "Files deleted."
        else
            echo "Dry run: No files were deleted."
        fi
    else
        echo "No files matching the criteria were found."
    fi
}

